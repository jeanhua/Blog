---
title: 操作系统复习笔记（更新中）
date: 2025-06-13 17:49:19
tags:
- 复习笔记
- 操作系统
categories:
- 学习笔记
typora-root-url: ./..

---

本笔记根据王道操作系统编写

## 一、导论

### 1.什么是操作系统？

> 操作系统（Operating System， OS）是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境，它是计算机系统中最基本的系统软件。

操作系统的功能和目标：**向上提供方便易用的服务**

### 2.操作系统的特征

![操作系统的特征](/image/操作系统复习笔记/操作系统的特征.png)

#### Ⅰ.并发

> 并发：指两个或多个事件在同一时间间隔内发生。这些事件**宏观上是同时发生的**，但**微观上是交替发生的**。

易混概念 “并行” 的定义 —— 指两个或多个事件在同一时刻同时发生

#### Ⅱ.共享

> 共享即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。

分为**互斥共享**和**\"同时\"共享**(宏观同时)

#### Ⅲ.虚拟

> 虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。

分为**时分复用**(如虚拟处理器)和空分**复用技术**(如虚拟存储器)

#### Ⅳ.异步

异步是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。

### 3.操作系统的发展与分类

![操作系统的分类](/image/操作系统复习笔记/操作系统的分类.png)

## 二、操作系统是如何运行的？

### 1.操作系统的运行机制

![操作系统的运行机制](/image/操作系统复习笔记/操作系统的运行机制.png)

#### Ⅰ.指令

**指令**是处理器能识别和执行的**最基本的命令**
注：与linux和windows的命令行区分开，本质是交互式命令接口

指令又分为两种指令：**特权指令**和**非特权指令**

#### Ⅱ.状态和切换

![两种指令](/image/操作系统复习笔记/两种指令.png)

操作系统可以使用一条**特权指令**，将PSW的标志位设置为**“用户态”**，CPU在运行程序时遇到非法事件时，会产生**中断信号**，强行变回内核态

![状态转换](/image/操作系统复习笔记/状态转换.png)

### 2.中断和异常

**中断**是让操作系统由用户态转为内核态的**唯一途径**，如果没有中断，CPU就会一直执行一个程序直到结束。

也就是说，没有中断，就没有并发性

#### Ⅰ.内中断（异常、例外）

1.当前程序执行的**指令是非法**的(比如应用程序打算执行特权指令)，或者执行的**指令参数是非法**的(比如除数是0)，就会产生中断信号

2.当应用程序需要使用系统内核服务时，就会执行一条**陷入指令（又叫trap指令、访管指令）**，会引发一个内部中断，让操作系统转向内核态，然后由中断处理程序来执行相关操作

> 系统调用就是通过陷入指令来完成的

注：陷入指令是用户态执行的，**不是特权指令**

#### Ⅱ.外中断（中断）

1.时钟中断：时钟部件每隔一段时间发出一个中断信号

> 时钟中断配合中断处理程序可以实现程序并发执行

2.I/O中断：输入输出设备发出的中断信号

#### Ⅲ.区别

看中断信号的产生**与当前的指令是否有关**，有关即是内中断，无关即是外中断。

![中断和异常](/image/操作系统复习笔记/中断和异常.png)

#### Ⅳ.中断的基本原理

![中断的基本原理](/image/操作系统复习笔记/中断的基本原理.png)

### 3.系统调用

> “系统调用”是操作系统提供给应用程序（程序员/编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以通过系统调用来请求获得操作系统内核的服务

#### Ⅰ.为什么需要系统调用

应用程序通过系统调用请求操作系统的服务。而系统中的各种共享资源都由操作系统内核统一掌管，因此凡是与共享资源有关的操作（如存储分配、I/O操作、文件管理等），都必须通过系统调用的方式向操作系统内核提出服务请求，由操作系统内核代为完成。这样可以**保证系统的稳定性和安全性**，**防止用户进行非法操作**。

#### Ⅱ.分类

![系统调用按功能分类](/image/操作系统复习笔记/系统调用按功能分类.png)

#### Ⅲ.系统调用的过程

![系统调用的过程](/image/操作系统复习笔记/系统调用的过程.png)

## 三、操作系统的体系

### 1.操作系统内核

内核是操作系统最基本、最核心的部分。 实现操作系统内核功能的那些程序就是内核程序。

![操作系统内核组成](/image/操作系统复习笔记/操作系统内核组成.png)

### 2.大内核(宏内核)与微内核对比

**大内核**：将操作系统主要功能模块都作为操作系统内核，运行在核心态

优点：高性能

缺点：内核代码庞大，难以维护

**微内核**：只把最基础的功能留在内核

优点：内核功能少，结构清晰，容易维护

缺点：需要频繁切换内核态与用户态，导致性能下降

### 3.其他体系结构

![计算机体系结构](/image/操作系统复习笔记/计算机体系结构.png)


## 四、操作系统的引导

操作系统的引导：计算机开机时如何启动操作系统的过程

![操作系统引导过程](/image/操作系统复习笔记/操作系统引导过程.png)

## 五、虚拟机

> 虚拟机：使用虚拟化技术，将一台物理机器虚拟化为多台虚拟机器（Virtual Machine, VM），每个虚拟机器都可以独立运行一个操作系统

虚拟机管理程序/虚拟机监控程序/virtual machine monitor(VMM)/Hypervisor

![第一类虚拟机](/image/操作系统复习笔记/第一类虚拟机.jpg)

> 通过将CPU时间片划分，可以把一个单核CPU虚拟为多核CPU

![第二类虚拟机](/image/操作系统复习笔记/第二类虚拟机.jpg)

![两类虚拟机的对比](/image/操作系统复习笔记/两类虚拟机的对比.png)

## 六、进程

### 1.进程是什么？

#### Ⅰ.**进程**和**程序**的区别：

程序：是静态的，就是个存放在磁盘里的可执行文件，就是一系列的**指令集合**。
进程（Process）：是动态的，是程序的一次**执行过程**，同一个程序多次执行会对应多个进程。

#### Ⅱ.操作系统怎么区分不同的进程？

操作系统会在创建线程时分配一个唯一的进程ID(PID)

#### Ⅲ.进程信息存放在哪里？

进程信息(比如进程ID，进程占用内存大小，进程占用CPU时间等等进程相关的信息)都被保存到一个数据结构PCB(Process Control Block，进程控制块)中。

![进程控制块](/image/操作系统复习笔记/进程控制块.png)

#### Ⅳ.程序运行过程

![程序运行过程](/image/操作系统复习笔记/程序运行过程.png)

#### Ⅴ.进程的组成

![进程的组成](/image/操作系统复习笔记/进程的组成.jpg)

#### Ⅵ.进程的特征

![进程的特征](/image/操作系统复习笔记/进程的特征.png)

### 2.进程的状态转换

#### Ⅰ.转换过程

![进程的状态转换](/image/操作系统复习笔记/进程的状态转换.png)

#### Ⅱ.进程的状态

![进程的状态](/image/操作系统复习笔记/进程的状态.jpg)

#### Ⅲ.进程的组织

![进程的组织](/image/操作系统复习笔记/进程的组织.png)

![进程的组织(链接方式)](/image/操作系统复习笔记/进程的组织(链接方式).png)

### 3.进程控制

> 进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。

简而言之，进程控制就是要**实现进程的状态转换**

#### Ⅰ.如何实现进程控制？

使用**原语**进行控制

> 原语由若干条指令组成的程序段，用来实现特定功能，**执行过程中不可被中断**，是操作系统核心的组成部分（由一组程序模块构成，非进程 ），常驻内存，通常在管态下执行。

原语具有原子性(可以使用**开中断指令**和**关中断指令**这两个特权指令来实现原子性)

![中断的过程](/image/操作系统复习笔记/中断的过程.jpg)

#### Ⅱ.进程控制相关的原语(理解为主,不需要强记)

- 进程的创建

![进程控制相关的原语](/image/操作系统复习笔记/进程控制相关的原语.jpg)

- 进程的终止

![进程控制相关的原语2](/image/操作系统复习笔记/进程控制相关的原语2.jpg)

- 进程的阻塞和呼唤

![进程控制相关的原语3](/image/操作系统复习笔记/进程控制相关的原语3.jpg)

进程的阻塞和呼唤原语是**成对出现**的

- 进程的切换

![进程控制相关的原语4](/image/操作系统复习笔记/进程控制相关的原语4.png)

#### Ⅲ.程序的执行过程

![程序的执行过程](/image/操作系统复习笔记/程序的执行过程.png)

**保存上下文:**

进程切换时会把相关的**寄存器的数据保存在PCB**中,比如PC,IR等寄存器,恢复时再把数据重新写回

### 4.进程通信

#### Ⅰ.为什么进程通信需要操作系统来支持?

进程是**分配系统资源的单位**(包括内存地址空间)，因此各进程拥有的内存地址空间**相互独立**。

![独立内存地址空间](/image/操作系统复习笔记/独立内存地址空间.png)

为了保证安全，一个进程**不能直接访问**另一个进程的地址空间。

#### Ⅱ.进程通信的类型

- 共享存储

  > 1. 基于存储区的共享：操作系统在内存中划出一块共享存储区，数据的形式、存放位置都由通信进程控制，而不是操作系统。这种共享方式速度很快，是一种高级通信方式。
  >
  > 2. 基于数据结构的共享：比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种低级通信方式。
  >
  > ![共享存储](/image/操作系统复习笔记/共享存储.png)
  >
  > 为了避免出错，各个进程对共享空间的访问是**互斥的**，各个进程可以通过操作系统内核提供的同步互斥工具（如P，V操作）

- 消息传递

  > 进程间的数据交换以格式化的消息（Message）为单位。进程通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换。
  >
  > ![消息传递](/image/操作系统复习笔记/消息传递.png)
  >
  > 1. 直接消息传递
  >    ![直接消息传递](/image/操作系统复习笔记/直接消息传递.png)
  > 2. 间接消息传递
  >    ![间接消息传递](/image/操作系统复习笔记/间接消息传递.png)

- 管道通信

  > 1. “管道”是一个特殊的共享文件，又名pipe文件。其实就是在内存中开辟一个大小固定的的缓存缓冲区
  >
  > 2. 本质上是一个**循环队列**，遵循先进先出的原则
  >
  > 3. 所以管道是一个**半双工通信**，某一时间只能实现**单向**的数据传输，如果要实现双向同时通信，需要创建两个管道。
  > 4. 当管道**写满**时，**写进程**将阻塞，直到读进程把数据读走；同理当管道**读空**时，**读进程**将阻塞，直到写进程往管道写入数据。
  > 5. 管道中的数据**一旦被读出，就彻底消失**。因此，当多个进程读同一个管道时，可能会错乱。对此，通常有两种解决方案：①一个管道允许多个写进程，一个读进程（2014年408真题高教社官方答案）；②允许有多个写进程，多个读进程，但系统会让各个读进程轮流从管道中读数据（Linux的方案）。

### 5.信号

注意区分：

信号量（Semaphore）——实现进程间的同步、互斥
信号（Signal）——实现进程间通信（IPC，Inter Process Communication）

#### Ⅰ.信号是什么？

信号（signal）：用于通知进程某个特定事件已经发生。进程收到一个信号后，对该信号进行处理。

e.g.当运行一个CLI程序时，在键盘上按下Ctrl+C，操作系统会向进程发送一个SIGINT信号，程序默认对SIGINT信号的处理为终止进程

信号一般保存在进程PCB中，由**2个N比特**的位向量保存（待处理信号，被阻塞信号）

![信号处理](/image/操作系统复习笔记/信号处理.png)

不少于N bit的位向量对应N种信号，blocked位向量也称**信号掩码**（signal mask）

#### Ⅱ.什么时候处理信号？

当进程从内核态转为用户态时（如：系统调用返回、或中断处理返回时），例行检查是否有待处理信号，如果有，就处理信号。

![进程执行信号处理](/image/操作系统复习笔记/进程执行信号处理.png)

#### Ⅲ.信号怎么作用？

①执行操作系统为此类信号设置的 **缺省（默认）信号处理程序**（某些信号默认忽略，不作处理）
②执行进程为此类信号设置 用户自定义信号处理程序（**自定义信号处理程序将覆盖①**）

- 用户进程之间是可以相互发送信号的（有限制），内核进程也可以给用户进程发送信号
- 信号处理程序运行结束后，通常会返回进程的下一条指令继续执行（除非信号处理程序将进程阻塞或终止）
- 一旦处理了某个信号，就将 pending 位重置为 0
- 重复收到的同类信号，将被简单地丢弃（因为仅有 1bit 记录一类待处理信号）
- 当同时收到多个不同类信号时，通常先处理信号更小的信号。
- **部分信号不能被用户自定义，也不能被阻塞**，比如Linux的SIGKILL、SIGSTOP信号

![信号默认处理程序](/image/操作系统复习笔记/信号默认处理程序.png)

#### Ⅳ.信号与异常的关系

![信号与异常的关系](/image/操作系统复习笔记/信号与异常的关系.png)

## 七、线程

### 1.导论

#### Ⅰ.为什么引入线程？

原本的计算机只能串行执行不同的程序，后面引入进程来让计算机可以并发执行不同程序，但是随着计算机的发展，进程也不再满足需求，于是引入了线程，让一个进程可以并发执行更多操作。

简单来说，**线程其实是进程的套娃**

> 其实线程还能再套娃，出现了协程等东西，比如Go语言的goroutine

线程是一个**基本CPU执行单元**，也是**程序执行流的最小单位**

注意：**进程**是**资源分配**的基本单位，**线程**是**调度**的基本单位

#### Ⅱ.线程的优点

线程可以理解为进程mini版

原先的进程并发需要切换不同的进程环境，系统开销很大，引入线程后，只需在同一进程内切换线程环境，**系统开销减少**

#### Ⅲ.线程的属性

![线程的属性](/image/操作系统复习笔记/线程的属性.png)

#### Ⅳ.线程的实现和多线程模型

##### 线程的实现：

历史背景:早期的操作系统(如:早期Unix)只支持进程，不支持线程。当时的“线程”是由**线程库**实现的

很多编程语言提供了强大的线程库,可以实现线程的创建、销毁、调度等功能。

**内核级线程**(Kernel-Level Thread,KLT,又称“内核支持的线程”)，大多数现代操作系统都实现了内核级线程,如 Windows, Linux

![内核级线程](/image/操作系统复习笔记/内核级线程.png)

1. 内核级线程的管理工作**由操作系统内核完成**。
2. **线程调度、切换**等工作都由内核负责，因此内核级线程的切换必然需要**在核心态下才能完成**。
3. 操作系统会为每个内核级线程建立相应的 TCB（Thread Control Block，线程控制块），通过 TCB 对线程进行管理。“内核级线程” 就是 “从操作系统内核视角看能看到的线程”
4. 优缺点
   优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。
   缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。

##### 多线程模型：

1. **一对一模型**：一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。

   优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。
   缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。

2. **多对一模型**：多个用户级线程映射到一个内核级线程。且一个进程只被分配一个内核级线程。

   优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高
   缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行

3. **多对多模型**：n 用户及线程映射到 m 个内核级线程（n>=m）。每个用户进程对应 m 个内核级线程。

   克服了多对一模型并发度不高的缺点（一个阻塞全体阻塞），又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。

操作系统只能发现内核级线程，所以**内核级线程才是处理机分配的单位**

> 用户级线程是 “**代码逻辑**” 的载体
> 内核级线程是 “**运行机会**” 的载体

#### Ⅴ.线程的状态和转换

![线程状态的切换](/image/操作系统复习笔记/线程状态的切换.png)

#### Ⅵ.线程的信息

**线程控制块**

![线程控制块](/image/操作系统复习笔记/线程控制块.png)

![线程表](/image/操作系统复习笔记/线程表.png)

### 2.处理机调度

> 一堆任务要处理,但由于资源有限,这些事情没法同时处理。这就需要确定某种规则来决定处理这些任务的顺序,这就是“调度”研究的问题。

#### Ⅰ.调度的三个层次

1. 高级调度（作业调度）

   按一定的原则从外存的作业后备队列中挑选一个作业调入内存,并创建进程。每个作业只调入一次,调出一次。作业调入时会建立PCB,调出时才撤销PCB。

2. 低级调度（进程调度/处理机调度）

   按照某种策略从就绪队列中选取一个进程,将处理机分配给它。

3. 中级调度（内存调度）

   按照某种策略决定将哪个处于挂起状态的进程重新调入内存。

   e.g.内存不够时，可将某些进程的数据调出外存，等内存空闲或者进程需要运行时再重新调入内存。暂时调到外存等待的进程状态为挂起状态，被挂起的进程PCB会被组织成挂起队列。

#### Ⅱ.三种调度的比较

|三种调度| 要做什么             | 调度发生在…                                                  | 发生频率              | 对进程状态的影响 |
| -------------------- | ------------------------------------------------------------ | --------------------- | ---------------- | -------------------------------- |
| 高级调度（作业调度） | 按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程 | 外存→内存（面向作业） | 最低             | 无→创建态→就绪态                 |
| 中级调度（内存调度） | 按照某种规则，从挂起队列中选择合适的进程将其数据调回内存     | 外存→内存（面向进程） | 中等             | 挂起态→就绪态（阻塞挂起→阻塞态） |
| 低级调度（进程调度） | 按照某种规则，从就绪队列中选择一个进程为其分配处理机         | 内存→CPU              | 最高             | 就绪态→运行态                    |

> 挂起和阻塞的区别：挂起的进程的映像在外存，阻塞的进程的映像在内存

#### Ⅲ.调度的时机、切换与过程、方式

1. 进程调度的时机

   ![进程调度的时机](/image/操作系统复习笔记/进程调度的时机.png)

2. 进程调度的方式

   **抢占式调度和非抢占式调度**

   ![两种进程调度的区别](/image/操作系统复习笔记/两种进程调度的区别.png)

3. 进程切换的过程

    - 核心概念区分

   | 类型         | 定义                                                         | 关联关系                     |
   | ------------ | ------------------------------------------------------------ | ---------------------------- |
   | 狭义进程调度 | 从**就绪队列**选一个待运行进程（可是暂停的，也可是全新进程） | 选进程的 “决策环节”          |
   | 进程切换     | 一个进程让出处理机 → 另一个进程占用处理机的**实际执行过程**  | 执行环节，狭义调度后可能触发 |
   | 广义进程调度 | 包含**狭义调度（选进程） + 进程切换（执行切换）** 两个完整步骤 | 完整调度流程                 |

   - 进程切换的具体工作

   进程切换时，内核需完成 **“保存旧进程状态 → 恢复新进程状态”** 的闭环：

   1. **保存旧进程**：将原运行进程的关键数据（程序计数器、程序状态字、数据寄存器等**处理机现场信息**）存入其 `PCB`（进程控制块）。
   2. **恢复新进程**：从新进程的 `PCB` 中读取上述信息，恢复到处理机硬件，让新进程继续执行。

   - 关键注意点

   进程切换**有性能代价**：频繁调度 / 切换会导致系统把大量时间花在 “保存 - 恢复” 流程上，**挤占进程实际执行时间**，最终降低整体效率。

   简单说，狭义调度是 “选谁运行”，切换是 “实际换人运行”，广义调度是 “选 + 换” 的完整流程；切换要保存 / 恢复进程数据，但太频繁会拖慢系统。



#### Ⅳ.调度器和闲逛进程

**调度器**

| 操作系统类型           | 调度程序（scheduler）的处理对象  | 调度逻辑                   |
| ---------------------- | -------------------------------- | -------------------------- |
| 不支持内核级线程的系统 | **进程**（如 “进程 1、进程 2…”） | 调度器直接管理 “进程” 队列 |
| 支持内核级线程的系统   | **内核线程**（如 “内核线程 1…”） | 调度器管理 “内核线程” 队列 |

调度器的作用是**决定 “谁获得 CPU 执行权”**，但 “调度对象” 取决于系统是否支持内核级线程：

- 无内核级线程 → 调度**进程**（进程是 CPU 调度的基本单元）。
- 有内核级线程 → 调度**内核线程**（内核线程直接对应 CPU 执行实体，更细粒度）。

**闲逛线程**

闲逛进程（idle 进程）是操作系统调度程序的“**保底机制**”：当系统中**无其他就绪进程 ** 时，调度器会选择运行 idle 进程，避免 CPU 空转。

作用：

- **填充 CPU 空闲**：确保 CPU 永远有 “任务” 执行（哪怕是最基础的空转），维持系统调度的连续性。
- **极简运行逻辑**：通常执行 “空操作” 或极低开销的指令，减少 CPU 能耗。

![闲逛进程](/image/操作系统复习笔记/闲逛进程.png)

#### Ⅴ.调度的目标(评价指标)

**CPU利用率**

> 早期 CPU 造价极高 → 追求 **“让 CPU 尽可能多工作”**，减少空闲浪费 → 引出 “CPU 利用率” 概念。

CPU忙碌时间占总时间的比例

![CPU利用率计算公式](/image/操作系统复习笔记/CPU利用率计算公式.png)

**系统吞吐量**

单位时间内完成的作业数量

![系统吞吐量计算公式](/image/操作系统复习笔记/系统吞吐量计算公式.png)

**周转时间**

作业提交给系统到作业完成的时间间隔

它包括四个部分:作业在外存后备队列上等待作业调度(高级调度)的时间、进程在就绪队列上等待进程调度(低级调度)的时间、进程在CPU上执行的时间、进程等待I/O操作完成的时间。后三项在一个作业的整个处理过程中,可能发生多次。

- 周转时间 = 作业完成时间 - 作业提交时间

**平均周转时间**

![平均周转时间](/image/操作系统复习笔记/平均周转时间计算公式.png)

**带权周转时间**

![带权周转时间](/image/操作系统复习笔记/带权周转时间.png)

**平均带权周转时间**

![平均带权周转时间](/image/操作系统复习笔记/平均带权周转时间.png)

**等待时间**

- 进程/作业处于等待处理机状态时间之和

1. 对于进程来说，等待时间就是指进程建立后等待被服务的时间之和，在**等待 I/O** 完成的期间其实进程也是在被服务的，所以**不计入等待时间**。
2. 对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。

一个作业总共总共需要被 CPU 服务多久，被 I/O 设备服务多久一般是确定不变的，因此调度算法其实只会影响作业 / 进程的等待时间。当然，与前面指标类似，也有 “平均等待时间” 来评价整体性能。

**响应时间**

- 用户从**提交请求**到**首次产生响应**所用的时间

### 3.调度算法

#### Ⅰ.**先来先服务（FCFS，first come first serve）**

**算法思想**：从 “公平” 角度出发，类比生活中排队买东西场景，遵循先到先得逻辑

**算法规则**：严格按照作业 / 进程到达的先后顺序，依次提供服务

调度应用：

- 作业调度：看作业到达外存后备队列的先后
- 进程调度：看进程到达就绪队列的先后

**抢占特性**：属于非抢占式算法，一旦开始服务，会持续到完成

优缺点：

- 优点：公平性强，算法实现简单易懂
- 缺点：短作业 / 进程若排在长作业 / 进程后，需长时间等待，带权周转时间大，用户体验差，整体对长作业有利、短作业不利（如排队买奶茶，长订单会让后面短订单等很久 ）

**饥饿问题**：不会导致饥饿，因为按顺序服务，每个作业 / 进程最终都会被处理 ，不过短作业等待久，是 “慢待” 而非 “饿到不处理” 。

#### Ⅱ.**短作业优先（SJF，shortest job first）**

**算法思想**：

- 最少平均等待时间
- 最少平均周转时间
- 最少平均带权周转时间

**算法规则**：核心逻辑：**“短者优先”** ，优先调度**要求服务时间最短**的作业 / 进程，让短任务快速执行，减少整体等待时长

**调度应用**：

- 作业调度：选后备队列中服务时间最短的作业
- 进程调度：选就绪队列中运行时间最短的进程（此时叫 SPF ），灵活适配两种调度场景

**抢占特性**：

- 基础版（SJF/SPF ）：**非抢占式**，一旦开始执行，会运行到结束或因 I/O 等主动放弃 CPU
- 抢占式版本（SRTN ）：若新到达的作业 / 进程服务时间更短，可抢占当前 CPU ，优先执行自身

**优缺点**：

| 维度     | 详情                                                         |
| -------- | ------------------------------------------------------------ |
| **优点** | 能有效降低系统整体的平均等待、周转时间，提升短任务处理效率，让 “小任务” 更快完成 |
| **缺点** | 1. **不公平性**：长作业 / 进程易被短任务 “挤兑”，长期得不到资源 2. **依赖用户输入**：作业 / 进程的服务时间由用户提供，可能不真实，无法保证绝对 “短优先” |

**饥饿问题**：**会导致饥饿**！若持续有短作业 / 进程到达，长作业 / 进程可能长期排不上队，陷入 “饥饿”；极端情况（一直没机会执行），甚至会演变成 **“饿死”** ，彻底无法推进。

#### Ⅲ.**高响应比优先（HRRN，highest response ratio next）**

**算法思想**：**“平衡公平与效率”**：既考虑作业 / 进程的**等待时间**（体现公平，避免长任务一直等），又兼顾**要求服务时间**（类似短作业优先，让短任务快执行 ），试图调和 FCFS 和 SJF 的优缺点

**算法规则**：

- **核心逻辑**：每次调度时，先为每个作业 / 进程计算 **“响应比”**，选响应比**最高**的执行
- **响应比公式**：
  ![响应比就算公式](/image/操作系统复习笔记/响应比计算公式.png)

**调度应用**：**通用性强**：既可用在**作业调度**（选外存后备队列的作业），也可用在**进程调度**（选就绪队列的进程）

**抢占特性**：

​	**非抢占式**：只有当前作业 / 进程**主动放弃 CPU**（比如完成、阻塞）时，才会触发调度，重新计算响应比选	新任务

**优缺点**：

| 维度     | 具体说明                                                     |
| -------- | ------------------------------------------------------------ |
| **优点** | 1. **融合 FCFS + SJF 优势**： - 等待时间相同时，选 “要求服务时间短” 的（继承 SJF 高效） - 要求服务时间相同时，选 “等待时间长” 的（继承 FCFS 公平） 2. **避免长作业饥饿**：长作业等待时间越久，响应比会持续增大，最终能被调度到 |
| **缺点** | 每次调度都要计算响应比，**增加系统开销**（需遍历队列统计等待时间、服务时间 ） |

**饥饿问题**：**不会导致饥饿**！长作业的响应比随等待时间增长而增大，迟早会被调度，从机制上避免了 “饿死” 风险

#### Ⅳ.**时间片轮转调度算法（RR, Round-Robin）**

**算法思想**：
模拟现实生活的 **"公平分配"** 场景（如会议发言计时器），通过强制分配 CPU 时间片实现多任务**轮流执行**，解决 FCFS 对短任务不友好的问题。

**算法规则**：

1. 核心逻辑：
   - 将 CPU 时间划分为固定长度的**时间片（Time Quantum）**
   - 就绪队列按 FCFS 排序，队首进程获得一个时间片
   - 时间片用完时，若进程未完成，则被抢占并重新加入**队尾**等待
   - 若进程在时间片结束前阻塞或完成，立即触发调度
2.  时间片选择原则：
   - **过长**（如 > 最大进程运行时间）：退化为 FCFS
   - **过短**（如 1ms）：频繁进程切换，系统开销剧增
   - **最佳实践**：通常设为 20ms ~ 100ms

**调度应用**：
**仅适用于进程调度**（因作业无 "中断-恢复" 概念），是现代操作系统的**基础调度算法**。

**抢占特性**：
**强抢占式**！由时钟中断强制触发时间片结束，无论进程是否主动释放 CPU。

**优缺点**：

|                  优点                  |                      缺点                      |
| :------------------------------------: | :--------------------------------------------: |
|     ✅ 对短任务友好：短任务快速响应     |     ❌ 高上下文切换开销：频繁中断和恢复进程     |
|   ✅ 公平性保障：每个进程定期获得 CPU   |    ❌ 平均等待时间较高：长任务需多次排队等待    |
|          ✅ 避免长任务垄断 CPU          | ❌ 性能依赖时间片大小：需权衡切换开销和响应速度 |
| ✅ 适用交互式系统：保证用户操作及时响应 |                                                |

**饥饿问题**：
**不会导致饥饿**！每个进程固定获得时间片，最终必然被执行。但长任务完成时间显著增长（需多次执行-等待循环）。

#### Ⅴ.**优先级调度算法（PSA, Priority Scheduling）**

**算法思想**：
模拟现实中的 **"VIP 优先"** 场景（如机场头等舱通道），根据任务重要性动态分配资源。

**算法规则**：

1.  核心逻辑：
   - 为每个作业/进程分配**优先级（Priority Number）**
   - 调度时选择优先级**最高**的任务执行
   - 优先级通常为整数，可自定义规则（如数值越小优先级越高）
2.  优先级类型：
   - **静态优先级**：创建时确定，终身不变（基于进程类型、内存需求等）
   - **动态优先级**：运行时动态调整（基于等待时间、执行历史等）

**调度应用**：
通用性强，​**​既可用于作业调度，也可用于进程调度​**​（如实时系统）。

**抢占特性**：

- **非抢占式**：进程运行到结束才触发调度
- **抢占式**（更常见）：当更高优先级任务到达时，立即抢占当前进程

**优缺点**：

|                 优点                 |                             缺点                             |
| :----------------------------------: | :----------------------------------------------------------: |
| ✅ 灵活适配场景：优先级反映任务重要性 |             ❌ 不公平性风险：低优先级任务长期等待             |
|   ✅ 适用实时系统：紧急任务优先处理   | ❌ 优先级倒置问题：低优先级进程持有高优先级所需资源时，导致阻塞 |
|       ✅ 动态优先级可平衡公平性       |               ❌ 系统开销：动态优先级需持续计算               |

**饥饿问题**：
**会导致饥饿**！持续存在高优先级任务时，低优先级任务可能永远不被执行（静态优先级尤其严重）。

**解决方案**：

- **老化（Aging）机制**：随等待时间增加逐步提升优先级（如每等待 5 分钟优先级+1）

#### Ⅵ.**多级反馈队列调度算法（MFQ, Multilevel Feedback Queue）**

**算法思想**：
模拟现实中的 **"多级服务通道"**（如银行普通窗⼝ vs VIP 窗⼝），通过**多队列+动态反馈**平衡响应速度与吞吐量。

**算法规则**：

1.  队列结构：
   - 创建多个**独立就绪队列**，每个队列赋予不同优先级和时间片
   - **队列优先级**：从上到下逐级降低（如 Q0 > Q1 > Q2）
   - **时间片大小**：从上到下逐级增大（如 Q0: 8ms, Q1: 16ms, Q2: 32ms）
2.  调度流程：
   - **新进程加入**：放入最高优先级队列（Q0）队尾
   - **队列内调度**：每个队列内采用 RR 算法
   - **时间片用完处理**：
     - 若在 Q_i 未完成，降级到 Q_{i+1} 队尾（优先级↓，时间片↑）
     - 在最低队列循环执行直到完成
   - **阻塞后恢复**：返回原队列队尾

**调度应用**：
主要应用于​**​进程调度​**​，是 UNIX、Linux 等系统的​**​默认调度算法​**​。

**抢占特性**：
​**​强抢占式​**​！当高优先级队列有新进程到达，或当前进程时间片用完，立即触发抢占。

**优缺点**：

|                         优点                          |                       缺点                       |
| :---------------------------------------------------: | :----------------------------------------------: |
|   ✅ 兼顾响应与吞吐：短任务快速完成 + 长任务高效执行   |  ❌ 配置复杂：需设定队列数量/优先级/时间片等参数  |
| ✅ 自适应性强：IO型任务自动升优先级，CPU型任务降级处理 | ❌ 优先级倒置风险：低优先级队列可能长期得不到执行 |
|      ✅ 避免饥饿：老化机制保证所有任务最终被执行       |                                                  |

**饥饿问题**：
**理论不会饥饿，实际可能导致饥饿**！最低优先级队列采用 RR 或 FCFS 保证最终执行。但长任务需经历多次降级，完成时间较长。

#### Ⅶ.各算法对比：

|          算法           |            关键特性            |         适用场景         | 饥饿风险 | 抢占性 |
| :---------------------: | :----------------------------: | :----------------------: | :------: | :----: |
|  **先来先服务(FCFS)**   |      简单公平，长任务有利      |        批处理系统        |    无    | 非抢占 |
| **短作业优先(SJF/SPF)** | 最短任务优先，平均等待时间最优 |       静态任务环境       |    有    | 非抢占 |
| **高响应比优先(HRRN)**  |     平衡等待时间与服务时间     |         通用调度         |    无    | 非抢占 |
|   **时间片轮转(RR)**    |       固定时间片轮流执行       |        交互式系统        |    无    |  抢占  |
|     **优先级(PSA)**     |          VIP优先机制           |    实时系统/关键任务     |    有    | 可配置 |
|  **多级反馈队列(MFQ)**  |        多队列+动态降级         | 通用操作系统(Unix/Linux) |    有    |  抢占  |

**补充：**

![多级队列调度算法](/image/操作系统复习笔记/多级队列调度算法.png)

### 4.多处理机调度算法

#### Ⅰ.公共就绪队列（Shared Ready Queue）

**核心机制**：
所有CPU共享同一个位于内核区的就绪进程队列，而非每个CPU拥有独立队列。

**工作流程**

1. 进程选择：
   - 任一CPU空闲时，运行调度程序，从**公共队列**中选取优先级最高的就绪进程（如CPU1选P1，CPU4选P4）。
2. 互斥访问：
   - CPU访问公共队列前需**上锁**，确保多CPU操作时的数据一致性。

**优点**

- **天然负载均衡**：
  所有CPU从同一队列取任务，繁忙CPU和空闲CPU的任务量自动均衡（如图中16个进程由多CPU共同处理）。

**缺点**

- 处理机亲和性差（Cache Affinity）：
  - 进程可能被任意CPU执行，频繁切换导致：
    - CPU缓存（Cache）失效，需重复加载数据。
    - 内存访问延迟增加，降低执行效率。

**亲和性优化方案**

- **软亲和（Soft Affinity）**：
  调度程序​**​优先分配进程到之前运行过的CPU​**​，减少切换频率，提升缓存命中率。

#### Ⅱ.私有就绪队列

**核心机制**：
**每个CPU独立维护专属就绪队列**，进程仅在绑定队列中被调度。

**工作流程**

1. 初始分配：
   - 新进程创建时，按预设策略（如轮询、负载最低）分配到**特定CPU的私有队列**（如图中P1分配到CPU1队列）。
2. 本地调度：
   - CPU空闲时**仅从自身队列**选取优先级最高进程运行（如CPU1调度P1，CPU2调度P2），无全局竞争。
3. 跨队列迁移（可选优化）：
   - 周期性检查负载均衡，将进程从**高负载CPU队列**迁移至**低负载CPU队列**。

**优点**

|       优势       |                             说明                             |
| :--------------: | :----------------------------------------------------------: |
| **高缓存亲和性** | 进程固定在同一CPU运行，缓存命中率高，减少内存访问延迟（*解决方案一核心痛点*） |
| **零全局锁竞争** |       无需公共队列锁，消除多CPU争用开销，提升调度效率        |
|  **局部性优化**  |           CPU频繁处理同批进程，TLB/缓存局部性更优            |

**缺点**

|       缺陷       |                             说明                             |
| :--------------: | :----------------------------------------------------------: |
| **负载失衡风险** |  静态分配可能导致队列负载不均（如CPU1堆积16进程，CPU4空闲）  |
|   **迁移开销**   |     动态负载均衡需跨队列迁移进程，引发缓存失效与调度延迟     |
|  **策略复杂度**  | 需实现额外负载监测和迁移算法（如Work Stealing），增加系统复杂性 |

## 七、线程同步

更新中，敬请期待……
